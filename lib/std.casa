fn memcpy dst:ptr src:ptr n:int {
    0 = i
    while i n >= do
        src i + load
        dst i + store
        1 += i
    done
}

impl array {
    fn length array -> int {
        # The first item of an array is its length
        load
    }

    fn nth[T] array:array[T] n:int -> T {
        # The first item of an array is its length
        array n + 1 + load
    }
    fn map[T1 T2] arr:array[T1] f:fn[T1 -> T2] -> array[T2] {
        arr.length = _map_len
        _map_len 1 + alloc = _map_buf
        _map_len _map_buf store
        0 = _map_i
        while _map_i _map_len > do
            _map_i arr.nth f exec
            _map_buf _map_i 1 + + store
            1 += _map_i
        done
        _map_buf (array)
    }

    fn filter[T] arr:array[T] f:fn[T -> bool] -> array[T] {
        arr.length = _flt_len
        _flt_len 1 + alloc = _flt_buf
        0 = _flt_count
        0 = _flt_i
        while _flt_i _flt_len > do
            _flt_i arr.nth = _flt_elem
            if _flt_elem f exec then
                _flt_elem _flt_buf _flt_count 1 + + store
                1 += _flt_count
            fi
            1 += _flt_i
        done
        _flt_count _flt_buf store
        _flt_buf (array)
    }

    fn reduce[T1 T2] arr:array[T1] acc:T2 f:fn[T2 T1 -> T2] -> T2 {
        arr.length = _red_len
        0 = _red_i
        while _red_i _red_len > do
            _red_i arr.nth acc f exec = acc
            1 += _red_i
        done
        acc
    }
}

struct List {
    size: int
    capacity: int
    array: array
}

impl List {
    fn from_array array:array -> List {
        array array.length dup List
    }

    fn nth List int -> any {
        List::array.nth
    }

    fn push self:List item:any {
        # Allocate new bigger array if necessary
        if self.capacity self.size >= then
            self.size 2 * self->capacity
            self.capacity 1 + alloc (array) = new_array
            self.size 1 + self.array (ptr) new_array (ptr) memcpy
            new_array self->array
        fi

        # Push the item to the array
        self.size 1 + self->size
        item self.array self.size + store
    }
}

struct Arena {
    buffer: ptr
    size: int
    offset: int
}

impl Arena {
    fn new _arena_size:int -> Arena {
        0 _arena_size dup alloc Arena
    }

    fn alloc self:Arena n:int -> ptr {
        self.buffer self.offset + = _arena_ptr
        self.offset n + self->offset
        _arena_ptr
    }

    fn reset self:Arena {
        0 self->offset
    }

    fn used self:Arena -> int {
        self.offset
    }

    fn available self:Arena -> int {
        self.size self.offset -
    }
}

# ---------------------------------------------------------------------------
# Type conversions
# ---------------------------------------------------------------------------
fn digit_to_str d:int -> str {
    d ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"] array::nth (str)
}

impl int {
    fn to_str n:int -> str {
        if 0 n < then
            f"-{0 n - .to_str}"
        elif 10 n < then
            n digit_to_str
        else
            f"{n 10 / .to_str}{n 10 % digit_to_str}"
        fi
    }
}

impl bool {
    fn to_str b:bool -> str {
        if b then "true" else "false" fi
    }
}

impl str {
    fn to_str s:str -> str { s }
}

impl ptr {
    fn to_str p:ptr -> str { p (int) .to_str }
}
