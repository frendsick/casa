fn memcpy dst:ptr src:ptr n:int {
    0 = i
    while i n > do
        src i + load8
        dst i + store8
        1 += i
    done
}

impl array {
    fn length array -> int {
        # Length is at offset 8 in the header
        (ptr) 8 + load64
    }

    fn nth[T] array:array[T] n:int -> T {
        # Data pointer is at offset 0 in the header
        array (ptr) load64 (ptr) n 8 * + load64 (T)
    }

    fn map[T1 T2] arr:array[T1] f:fn[T1 -> T2] -> array[T2] {
        arr.length = map_len
        map_len 2 + 8 * alloc = map_buf
        # Store data_ptr (map_buf + 16) at offset 0
        map_buf (ptr) 16 + map_buf (ptr) store64
        # Store length at offset 8
        map_len map_buf (ptr) 8 + store64
        0 = map_i
        while map_i map_len > do
            map_i arr.nth f exec
            map_buf (ptr) load64 (ptr) map_i 8 * + store64
            1 += map_i
        done
        map_buf (array)
    }

    fn filter[T] arr:array[T] f:fn[T -> bool] -> array[T] {
        arr.length = flt_len
        flt_len 2 + 8 * alloc = flt_buf
        # Store data_ptr (flt_buf + 16) at offset 0
        flt_buf (ptr) 16 + flt_buf (ptr) store64
        # Store initial length 0 at offset 8
        0 flt_buf (ptr) 8 + store64
        0 = flt_count
        0 = flt_i
        while flt_i flt_len > do
            flt_i arr.nth = flt_elem
            if flt_elem f exec then
                flt_elem flt_buf (ptr) load64 (ptr) flt_count 8 * + store64
                1 += flt_count
            fi
            1 += flt_i
        done
        # Update length at offset 8
        flt_count flt_buf (ptr) 8 + store64
        flt_buf (array)
    }

    fn reduce[T1 T2] arr:array[T1] acc:T2 f:fn[T2 T1 -> T2] -> T2 {
        arr.length = red_len
        0 = red_i
        while red_i red_len > do
            red_i arr.nth acc f exec = acc
            1 += red_i
        done
        acc
    }
}

struct List {
    data:     ptr
    size:     int
    capacity: int
}

impl List {
    fn new -> List {
        8 0 64 alloc List
    }

    fn from_array[T] arr:array[T] -> List[T] {
        arr.length dup arr (ptr) load64 (ptr) List
    }

    fn length self:List -> int {
        self.size
    }

    fn get[T] self:List[T] n:int -> T {
        if self.size n >= 0 n < || then
            "error: List index out of bounds\n" print
            1 60 syscall1 drop
        fi
        self.data n 8 * + load64 (T)
    }

    fn set[T] self:List[T] n:int item:T {
        if self.size n >= 0 n < || then
            "error: List index out of bounds\n" print
            1 60 syscall1 drop
        fi
        item self.data n 8 * + store64
    }

    fn push[T] self:List[T] item:T {
        if self.capacity self.size >= then
            self.capacity 2 * self->capacity
            self.capacity 8 * alloc = new_data
            self.size 8 * self.data new_data memcpy
            new_data self->data
        fi
        item self.data self.size 8 * + store64
        self.size 1 + self->size
    }

    fn pop[T] self:List[T] -> T {
        if 0 self.size <= then
            "error: pop from empty List\n" print
            1 60 syscall1 drop
        fi
        self.size 1 - self->size
        self.data self.size 8 * + load64 (T)
    }

    fn slice[T] self:List[T] start:int end:int -> array[T] {
        if 0 start < self.size end > || end start > || then
            "error: List slice out of bounds\n" print
            1 60 syscall1 drop
        fi
        16 alloc = hdr
        self.data start 8 * + hdr (ptr) store64
        end start - hdr (ptr) 8 + store64
        hdr (array)
    }

    fn to_array[T] self:List[T] -> array[T] {
        self.size 0 self.slice
    }
}

# ---------------------------------------------------------------------------
# Type conversions
# ---------------------------------------------------------------------------
fn digit_to_str d:int -> str {
    d ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"] array::nth (str)
}

impl int {
    fn to_str n:int -> str {
        if 0 n < then
            f"-{0 n - .to_str}"
        elif 10 n < then
            n digit_to_str
        else
            f"{n 10 / .to_str}{n 10 % digit_to_str}"
        fi
    }
}

impl bool {
    fn to_str b:bool -> str {
        if b then "true" else "false" fi
    }
}

impl str {
    fn to_str s:str -> str { s }

    fn length s:str -> int {
        s (ptr) load64
    }

    fn at s:str index:int -> char {
        s (ptr) 8 + index + load8 (char)
    }

    fn set s:str index:int c:char {
        c s (ptr) 8 + index + store8
    }

    fn as_cstr s:str -> cstr {
        s (ptr) 8 + (cstr)
    }

    fn eq b:str a:str -> bool {
        a .length = eq_a_len
        b .length = eq_b_len
        if eq_a_len eq_b_len != then
            false
        else
            true = eq_matched
            0 = eq_i
            while eq_i eq_a_len > do
                if eq_i a .at eq_i b .at != then
                    false = eq_matched
                    break
                fi
                1 += eq_i
            done
            eq_matched
        fi
    }

    fn substring len:int start:int s:str -> str {
        # Allocate: 8 (length) + len (data) + 1 (null) bytes
        len 9 + alloc (str) = sub_buf
        # Store length
        len sub_buf (ptr) store64
        # Copy bytes
        0 = sub_i
        while sub_i len > do
            start sub_i + s .at sub_i sub_buf.set
            1 += sub_i
        done
        # Store null terminator
        0 (char) len sub_buf.set
        sub_buf
    }

    fn find needle:str s:str -> int {
        s .length = fnd_s_len
        needle .length = fnd_n_len
        if fnd_n_len fnd_s_len < then
            0 1 -
        else
            0 1 - = fnd_pos
            0 = fnd_i
            while fnd_i fnd_s_len fnd_n_len - 1 + > do
                true = fnd_found
                0 = fnd_j
                while fnd_j fnd_n_len > do
                    if fnd_i fnd_j + s .at fnd_j needle .at != then
                        false = fnd_found
                        break
                    fi
                    1 += fnd_j
                done
                if fnd_found then
                    fnd_i = fnd_pos
                    break
                fi
                1 += fnd_i
            done
            fnd_pos
        fi
    }

    fn starts_with prefix:str s:str -> bool {
        s .length = sw_s_len
        prefix .length = sw_p_len
        if sw_p_len sw_s_len < then
            false
        else
            true = sw_matched
            0 = sw_i
            while sw_i sw_p_len > do
                if sw_i s .at sw_i prefix .at != then
                    false = sw_matched
                    break
                fi
                1 += sw_i
            done
            sw_matched
        fi
    }

    fn ends_with suffix:str s:str -> bool {
        s .length = ew_s_len
        suffix .length = ew_suf_len
        if ew_suf_len ew_s_len < then
            false
        else
            ew_s_len ew_suf_len - = ew_off
            true = ew_matched
            0 = ew_i
            while ew_i ew_suf_len > do
                if ew_off ew_i + s .at ew_i suffix .at != then
                    false = ew_matched
                    break
                fi
                1 += ew_i
            done
            ew_matched
        fi
    }

    fn concat b:str a:str -> str {
        f"{a}{b}"
    }
}

impl cstr {
    fn to_str s:cstr -> str {
        # Find length by scanning for null byte
        0 = cs_len
        while s (ptr) cs_len + load8 0 != do
            1 += cs_len
        done
        # Allocate str: 8 (length) + cs_len (data) + 1 (null)
        cs_len 9 + alloc (str) = cs_buf
        cs_len cs_buf (ptr) store64
        # Copy bytes
        0 = cs_i
        while cs_i cs_len > do
            s (ptr) cs_i + load8 (char) cs_i cs_buf.set
            1 += cs_i
        done
        # Null terminator
        0 (char) cs_len cs_buf.set
        cs_buf
    }
}

# ---------------------------------------------------------------------------
# File I/O
# ---------------------------------------------------------------------------
0 = O_RDONLY
1 = O_WRONLY
64 = O_CREAT
512 = O_TRUNC

impl file {
    fn open path:str flags:int mode:int -> int {
        mode flags path.as_cstr (ptr) 2 syscall3
    }

    fn read fd:int buf:ptr size:int -> int {
        size buf fd 0 syscall3
    }

    fn write fd:int data:str -> int {
        data .length data.as_cstr (ptr) fd 1 syscall3
    }

    fn close fd:int -> int {
        fd 3 syscall1
    }

    fn read_all path:str -> str {
        0 O_RDONLY path file::open = ra_fd
        if 0 ra_fd < then
            "error: could not open file\n" print
            1 60 syscall1 drop
        fi
        2 0 ra_fd 8 syscall3 = ra_size
        0 0 ra_fd 8 syscall3 drop
        ra_size 9 + alloc (str) = ra_buf
        ra_size ra_buf (ptr) store64
        ra_size ra_buf.as_cstr (ptr) ra_fd 0 syscall3 drop
        0 (char) ra_size ra_buf.set
        ra_fd file::close drop
        ra_buf
    }

    fn write_all path:str content:str -> bool {
        420 O_WRONLY O_CREAT | O_TRUNC | path file::open = wa_fd
        if 0 wa_fd < then
            false
        else
            content wa_fd file::write drop
            wa_fd file::close drop
            true
        fi
    }

    fn remove path:str -> int {
        path.as_cstr (ptr) 87 syscall1
    }
}

# ---------------------------------------------------------------------------
# Character classification
# ---------------------------------------------------------------------------
impl char {
    fn is_digit c:char -> bool {
        '0' c >= '9' c <= &&
    }

    fn is_upper c:char -> bool {
        'A' c >= 'Z' c <= &&
    }

    fn is_lower c:char -> bool {
        'a' c >= 'z' c <= &&
    }

    fn is_alpha c:char -> bool {
        c .is_upper c .is_lower ||
    }

    fn is_space c:char -> bool {
        c ' ' == c '\t' == || c '\n' == || c '\r' == ||
    }
}

impl ptr {
    fn to_str p:ptr -> str { p (int) .to_str }
}

impl option {
    fn is_some self:option -> bool {
        self (ptr) load64 1 ==
    }
    fn is_none self:option -> bool {
        self (ptr) load64 0 ==
    }
    fn unwrap[T] self:option[T] -> T {
        if self.is_none then
            "error: called unwrap on None\n" print
            60 231 syscall1 drop
        fi
        self (ptr) 8 + load64 (T)
    }
    fn unwrap_or[T] self:option[T] default:T -> T {
        if self.is_some then
            self.unwrap
        else
            default
        fi
    }
}

# ---------------------------------------------------------------------------
# Traits
# ---------------------------------------------------------------------------
trait Hashable {
    fn hash self:self -> int
    fn eq self:self other:self -> bool
}

# ---------------------------------------------------------------------------
# Hash helpers
# ---------------------------------------------------------------------------
fn str_hash s:str -> int {
    5381 = sh_h
    0 = sh_i
    while sh_i s .length > do
        sh_h 5 << sh_h + sh_i s .at (int) + = sh_h
        1 += sh_i
    done
    if 0 sh_h < then 0 sh_h - = sh_h fi
    sh_h
}

fn int_hash n:int -> int {
    if 0 n < then 0 n - else n fi
}

impl str {
    fn hash self:str -> int { self str_hash }
}

impl int {
    fn hash self:int -> int { self int_hash }
    fn eq self:int other:int -> bool { self other == }
}

# ---------------------------------------------------------------------------
# Map[K V] - Hash map with separate chaining
# ---------------------------------------------------------------------------
# Entry layout: 24 bytes per entry (key:8, value:8, next:8)
# Bucket array: capacity * 8 bytes (each slot is a ptr to entry or 0)
16 = MAP_INITIAL_CAP

struct Map {
    buckets:  ptr
    size:     int
    capacity: int
}

impl Map {
    fn new[K: Hashable, V] -> Map[K V] {
        MAP_INITIAL_CAP 8 * alloc = mb
        0 = mb_i
        while mb_i MAP_INITIAL_CAP > do
            0 mb mb_i 8 * + store64
            1 += mb_i
        done
        MAP_INITIAL_CAP 0 mb Map (Map[K V])
    }

    fn length self:Map -> int {
        self.size
    }

    fn get[K: Hashable, V] self:Map[K V] key:K -> option[V] {
        key K::hash self.capacity % = mg_idx
        self.buckets mg_idx 8 * + load64 = mg_entry
        while 0 mg_entry != do
            mg_entry (ptr) load64 (K) = mg_nk
            if key mg_nk K::eq then
                mg_entry (ptr) 8 + load64 (V) some
                return
            fi
            mg_entry (ptr) 16 + load64 = mg_entry
        done
        none (option[V])
    }

    fn has[K: Hashable, V] self:Map[K V] key:K -> bool {
        key self.get .is_some
    }

    fn set[K: Hashable, V] self:Map[K V] value:V key:K -> Map[K V] {
        key K::hash self.capacity % = ms_idx
        self.buckets ms_idx 8 * + load64 = ms_entry
        while 0 ms_entry != do
            ms_entry (ptr) load64 (K) = ms_nk
            if key ms_nk K::eq then
                value ms_entry (ptr) 8 + store64
                self (Map[K V])
                return
            fi
            ms_entry (ptr) 16 + load64 = ms_entry
        done
        # New entry
        24 alloc = ms_new
        key ms_new (ptr) store64
        value ms_new (ptr) 8 + store64
        self.buckets ms_idx 8 * + load64 ms_new (ptr) 16 + store64
        ms_new self.buckets ms_idx 8 * + store64
        self.size 1 + self->size
        # Resize at 75% load
        if self.capacity 3 * 4 / self.size >= then
            self Map::resize
        fi
        self (Map[K V])
    }

    fn delete[K: Hashable, V] self:Map[K V] key:K -> Map[K V] {
        key K::hash self.capacity % = md_idx
        0 = md_prev
        self.buckets md_idx 8 * + load64 = md_entry
        while 0 md_entry != do
            md_entry (ptr) load64 (K) = md_nk
            if key md_nk K::eq ! then
                md_entry = md_prev
                md_entry (ptr) 16 + load64 = md_entry
                continue
            fi
            md_entry (ptr) 16 + load64 = md_next
            if 0 md_prev == then
                md_next self.buckets md_idx 8 * + store64
            else
                md_next md_prev (ptr) 16 + store64
            fi
            self.size 1 - self->size
            self (Map[K V])
            return
        done
        self (Map[K V])
    }

    fn resize[K: Hashable, V] self:Map[K V] {
        self.capacity 2 * = mr_new_cap
        mr_new_cap 8 * alloc = mr_new_bk
        0 = mr_i
        while mr_i mr_new_cap > do
            0 mr_new_bk mr_i 8 * + store64
            1 += mr_i
        done
        0 = mr_i
        while mr_i self.capacity > do
            self.buckets mr_i 8 * + load64 = mr_entry
            while 0 mr_entry != do
                mr_entry (ptr) 16 + load64 = mr_next
                mr_entry (ptr) load64 (K) K::hash mr_new_cap % = mr_idx
                mr_new_bk mr_idx 8 * + load64 mr_entry (ptr) 16 + store64
                mr_entry mr_new_bk mr_idx 8 * + store64
                mr_next = mr_entry
            done
            1 += mr_i
        done
        mr_new_bk self->buckets
        mr_new_cap self->capacity
    }

    fn keys[K V] self:Map[K V] -> List[K] {
        List::new (List[K]) = mk_list
        0 = mk_i
        while mk_i self.capacity > do
            self.buckets mk_i 8 * + load64 = mk_entry
            while 0 mk_entry != do
                mk_entry (ptr) load64 (K) mk_list.push
                mk_entry (ptr) 16 + load64 = mk_entry
            done
            1 += mk_i
        done
        mk_list
    }

    fn values[K V] self:Map[K V] -> List[V] {
        List::new (List[V]) = mv_list
        0 = mv_i
        while mv_i self.capacity > do
            self.buckets mv_i 8 * + load64 = mv_entry
            while 0 mv_entry != do
                mv_entry (ptr) 8 + load64 (V) mv_list.push
                mv_entry (ptr) 16 + load64 = mv_entry
            done
            1 += mv_i
        done
        mv_list
    }
}

# ---------------------------------------------------------------------------
# Set[K] - Hash set backed by Map
# ---------------------------------------------------------------------------
struct Set {
    map: Map
}

impl Set {
    fn new[K: Hashable] -> Set[K] {
        Map::new (Map[K int]) Set (Set[K])
    }

    fn length self:Set -> int {
        self.map.length
    }

    fn has[K: Hashable] self:Set[K] key:K -> bool {
        key self.map (Map[K int]) .has
    }

    fn add[K: Hashable] self:Set[K] key:K -> Set[K] {
        key 0 self.map (Map[K int]) .set (Map) self->map
        self (Set[K])
    }

    fn remove[K: Hashable] self:Set[K] key:K -> Set[K] {
        key self.map (Map[K int]) .delete (Map) self->map
        self (Set[K])
    }

    fn to_list[K] self:Set[K] -> List[K] {
        self.map (Map[K int]) .keys
    }
}
