fn memcpy dst:ptr src:ptr n:int {
    0 = i
    while i n > do
        src i + load8
        dst i + store8
        1 += i
    done
}

impl array {
    fn length array -> int {
        # The first item of an array is its length
        (ptr) load64
    }

    fn nth[T] array:array[T] n:int -> T {
        # The first item of an array is its length
        array (ptr) n 1 + 8 * + load64 (T)
    }
    fn map[T1 T2] arr:array[T1] f:fn[T1 -> T2] -> array[T2] {
        arr.length = map_len
        map_len 1 + 8 * alloc = map_buf
        map_len map_buf (ptr) store64
        0 = map_i
        while map_i map_len > do
            map_i arr.nth f exec
            map_buf (ptr) map_i 1 + 8 * + store64
            1 += map_i
        done
        map_buf (array)
    }

    fn filter[T] arr:array[T] f:fn[T -> bool] -> array[T] {
        arr.length = flt_len
        flt_len 1 + 8 * alloc = flt_buf
        0 = flt_count
        0 = flt_i
        while flt_i flt_len > do
            flt_i arr.nth = flt_elem
            if flt_elem f exec then
                flt_elem flt_buf (ptr) flt_count 1 + 8 * + store64
                1 += flt_count
            fi
            1 += flt_i
        done
        flt_count flt_buf (ptr) store64
        flt_buf (array)
    }

    fn reduce[T1 T2] arr:array[T1] acc:T2 f:fn[T2 T1 -> T2] -> T2 {
        arr.length = red_len
        0 = red_i
        while red_i red_len > do
            red_i arr.nth acc f exec = acc
            1 += red_i
        done
        acc
    }
}

struct List {
    size: int
    capacity: int
    array: array
}

impl List {
    fn from_array array:array -> List {
        array array.length dup List
    }

    fn nth List int -> any {
        List::array.nth
    }

    fn push self:List item:any {
        # Allocate new bigger array if necessary
        if self.capacity self.size >= then
            self.size 2 * self->capacity
            self.capacity 1 + 8 * alloc (array) = new_arr
            self.size 1 + 8 * self.array (ptr) new_arr (ptr) memcpy
            new_arr self->array
        fi

        # Push the item to the array
        self.size 1 + self->size
        item self.array (ptr) self.size 8 * + store64
    }
}

# ---------------------------------------------------------------------------
# Type conversions
# ---------------------------------------------------------------------------
fn digit_to_str d:int -> str {
    d ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"] array::nth (str)
}

impl int {
    fn to_str n:int -> str {
        if 0 n < then
            f"-{0 n - .to_str}"
        elif 10 n < then
            n digit_to_str
        else
            f"{n 10 / .to_str}{n 10 % digit_to_str}"
        fi
    }
}

impl bool {
    fn to_str b:bool -> str {
        if b then "true" else "false" fi
    }
}

impl str {
    fn to_str s:str -> str { s }

    fn length s:str -> int {
        s (ptr) load64
    }

    fn at s:str index:int -> char {
        s (ptr) 8 + index + load8 (char)
    }

    fn set s:str index:int c:char {
        c s (ptr) 8 + index + store8
    }

    fn as_cstr s:str -> cstr {
        s (ptr) 8 + (cstr)
    }

    fn eq b:str a:str -> bool {
        a .length = eq_a_len
        b .length = eq_b_len
        if eq_a_len eq_b_len != then
            false
        else
            true = eq_matched
            0 = eq_i
            while eq_i eq_a_len > do
                if eq_i a .at eq_i b .at != then
                    false = eq_matched
                    break
                fi
                1 += eq_i
            done
            eq_matched
        fi
    }

    fn substring len:int start:int s:str -> str {
        # Allocate: 8 (length) + len (data) + 1 (null) bytes
        len 9 + alloc (str) = sub_buf
        # Store length
        len sub_buf (ptr) store64
        # Copy bytes
        0 = sub_i
        while sub_i len > do
            start sub_i + s .at sub_i sub_buf.set
            1 += sub_i
        done
        # Store null terminator
        0 (char) len sub_buf.set
        sub_buf
    }

    fn find needle:str s:str -> int {
        s .length = fnd_s_len
        needle .length = fnd_n_len
        if fnd_n_len fnd_s_len < then
            0 1 -
        else
            0 1 - = fnd_pos
            0 = fnd_i
            while fnd_i fnd_s_len fnd_n_len - 1 + > do
                true = fnd_found
                0 = fnd_j
                while fnd_j fnd_n_len > do
                    if fnd_i fnd_j + s .at fnd_j needle .at != then
                        false = fnd_found
                        break
                    fi
                    1 += fnd_j
                done
                if fnd_found then
                    fnd_i = fnd_pos
                    break
                fi
                1 += fnd_i
            done
            fnd_pos
        fi
    }

    fn starts_with prefix:str s:str -> bool {
        s .length = sw_s_len
        prefix .length = sw_p_len
        if sw_p_len sw_s_len < then
            false
        else
            true = sw_matched
            0 = sw_i
            while sw_i sw_p_len > do
                if sw_i s .at sw_i prefix .at != then
                    false = sw_matched
                    break
                fi
                1 += sw_i
            done
            sw_matched
        fi
    }

    fn ends_with suffix:str s:str -> bool {
        s .length = ew_s_len
        suffix .length = ew_suf_len
        if ew_suf_len ew_s_len < then
            false
        else
            ew_s_len ew_suf_len - = ew_off
            true = ew_matched
            0 = ew_i
            while ew_i ew_suf_len > do
                if ew_off ew_i + s .at ew_i suffix .at != then
                    false = ew_matched
                    break
                fi
                1 += ew_i
            done
            ew_matched
        fi
    }

    fn concat b:str a:str -> str {
        f"{a}{b}"
    }
}

impl cstr {
    fn to_str s:cstr -> str {
        # Find length by scanning for null byte
        0 = cs_len
        while s (ptr) cs_len + load8 0 != do
            1 += cs_len
        done
        # Allocate str: 8 (length) + cs_len (data) + 1 (null)
        cs_len 9 + alloc (str) = cs_buf
        cs_len cs_buf (ptr) store64
        # Copy bytes
        0 = cs_i
        while cs_i cs_len > do
            s (ptr) cs_i + load8 (char) cs_i cs_buf.set
            1 += cs_i
        done
        # Null terminator
        0 (char) cs_len cs_buf.set
        cs_buf
    }
}

# ---------------------------------------------------------------------------
# File I/O
# ---------------------------------------------------------------------------
0 = O_RDONLY
1 = O_WRONLY
64 = O_CREAT
512 = O_TRUNC

impl file {
    fn open path:str flags:int mode:int -> int {
        mode flags path.as_cstr (ptr) 2 syscall3
    }

    fn read fd:int buf:ptr size:int -> int {
        size buf fd 0 syscall3
    }

    fn write fd:int data:str -> int {
        data .length data.as_cstr (ptr) fd 1 syscall3
    }

    fn close fd:int -> int {
        fd 3 syscall1
    }

    fn read_all path:str -> str {
        0 0 path file::open = ra_fd
        if 0 ra_fd < then
            "error: could not open file\n" print
            1 60 syscall1 drop
        fi
        2 0 ra_fd 8 syscall3 = ra_size
        0 0 ra_fd 8 syscall3 drop
        ra_size 9 + alloc (str) = ra_buf
        ra_size ra_buf (ptr) store64
        ra_size ra_buf.as_cstr (ptr) ra_fd 0 syscall3 drop
        0 (char) ra_size ra_buf.set
        ra_fd file::close drop
        ra_buf
    }

    fn write_all path:str content:str -> bool {
        420 O_WRONLY O_CREAT | O_TRUNC | path file::open = wa_fd
        if 0 wa_fd < then
            false
        else
            content wa_fd file::write drop
            wa_fd file::close drop
            true
        fi
    }

    fn remove path:str -> int {
        path.as_cstr (ptr) 87 syscall1
    }
}

# ---------------------------------------------------------------------------
# Character classification
# ---------------------------------------------------------------------------
impl char {
    fn is_digit c:char -> bool {
        '0' c >= '9' c <= &&
    }

    fn is_upper c:char -> bool {
        'A' c >= 'Z' c <= &&
    }

    fn is_lower c:char -> bool {
        'a' c >= 'z' c <= &&
    }

    fn is_alpha c:char -> bool {
        c .is_upper c .is_lower ||
    }

    fn is_space c:char -> bool {
        c ' ' == c '\t' == || c '\n' == || c '\r' == ||
    }
}

impl ptr {
    fn to_str p:ptr -> str { p (int) .to_str }
}

impl option {
    fn is_some self:option -> bool {
        self (ptr) load64 1 ==
    }
    fn is_none self:option -> bool {
        self (ptr) load64 0 ==
    }
    fn unwrap[T] self:option[T] -> T {
        if self.is_none then
            "error: called unwrap on None\n" print
            60 231 syscall1 drop
        fi
        self (ptr) 8 + load64 (T)
    }
    fn unwrap_or[T] self:option[T] default:T -> T {
        if self.is_some then
            self.unwrap
        else
            default
        fi
    }
}
