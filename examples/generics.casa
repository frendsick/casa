# Generics - type-safe polymorphic functions
#
# Type variables in [brackets] are resolved to concrete types at call site.
# No runtime cost as generics are purely compile-time.

# identity: pass any single value through unchanged
fn id[T] T -> T { }

42 id print "\n" print         # 42
"hello" id print "\n" print    # hello

# swap: works on any two types
fn swap_t[T1 T2] T1 T2 -> T1 T2 { swap }

1 2 swap_t
print "\n" print print "\n" print # 1 2

# select first / second from a pair
fn first[T1 T2] a:T1 b:T2 -> T1 { a }
fn second[T1 T2] a:T1 b:T2 -> T2 { b }

42 "hello" first print "\n" print  # hello
42 "hello" second print "\n" print # 42

# mixing generic and concrete types
fn tag[T] T -> T str { "tagged" }

99 tag print "\n" print print "\n" print # tagged 99

# generic method in an impl block
struct Pair {
    x: int
    y: int
}

impl Pair {
    # Replace the x field with any value, return the old x
    fn swap_x[T] self:Pair T -> int {
        self.x
    }
}

10 20 Pair = p
999 p.swap_x print "\n" print # 10 (the old x value)
