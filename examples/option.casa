# Option type - representing values that may or may not exist
#
# some wraps a value into option[T], none creates an empty option.
# Methods: is_some, is_none, unwrap, unwrap_or

include "../lib/std.casa"

# Creating options
42 some = maybe_int       # option[int]
"hello" some = maybe_str  # option[str]
none = empty              # option (compatible with any option[T])

# Checking presence
if maybe_int.is_some then
    "maybe_int has a value\n" print
fi

if empty.is_none then
    "empty has no value\n" print
fi

# Unwrapping values
maybe_int.unwrap print "\n" print     # 42
maybe_str.unwrap print "\n" print     # hello

# unwrap_or provides a default when the option is none
# default value is pushed before the option
0 empty.unwrap_or print "\n" print     # 0 (fallback for none)
0 maybe_int.unwrap_or print "\n" print # 42 (has a value, default ignored)

# Using options with generic functions
fn id[T] T -> T { }
42 some id .unwrap print "\n" print    # 42

# Branching with option types â€” none and some in different branches
fn safe_head arr:array[int] -> option[int] {
    if 0 arr .length < then
        0 arr array::nth some
    else
        none
    fi
}

[1, 2, 3] safe_head .unwrap print "\n" print  # 1
[] (array[int]) safe_head .is_none print "\n" print  # 1 (true)
